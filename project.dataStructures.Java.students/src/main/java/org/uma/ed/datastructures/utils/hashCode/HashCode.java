package org.uma.ed.datastructures.utils.hashCode;

import java.util.Objects;

/**
 * Provides utility methods to compute hash codes for {@link Iterable} collections.
 * <p>
 * This class is designed to work in tandem with the {@code Equals} utility class,
 * ensuring that the fundamental contract between {@code equals()} and {@code hashCode()} is maintained:
 * if two objects are equal, they must have the same hash code.
 * <p>
 * It offers two hashing strategies:
 * 1. Order-dependent: Produces a hash code sensitive to the order of elements. It should be used
 *    for data structures where sequence matters (e.g., lists). This is compatible with
 *    {@code Equals.orderDependent()}.
 * 2. Order-independent: Produces a hash code that is the same regardless of element order. It should
 *    be used for structures where order is irrelevant (e.g., sets, bags). This is compatible with
 *    {@code Equals.orderIndependent()}.
 * <p>
 * All hash codes are computed safely using {@link java.util.Objects#hashCode(Object)}, which correctly
 * handles {@code null} elements. This is a utility class and is not meant to be instantiated.
 *
 * @author Pepe Gallardo, Data Structures, Grado en Inform√°tica. UMA.
 */
public final class HashCode {

  /**
   * Private constructor to prevent instantiation of this utility class.
   */
  private HashCode() {
    throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
  }

  /**
   * Computes an order-dependent hash code for an iterable.
   * <p>
   * The hash code is generated based on the elements and their specific sequence in the
   * iterable. This implementation follows the standard pattern for hashing sequences,
   * ensuring that two iterables with the same elements in the same order will produce
   * the same hash code.
   * <p>
   * This method is the correct counterpart for {@code Equals.orderDependent()}.
   *
   * @param <T>      the type of elements in the iterable.
   * @param iterable the iterable to hash.
   * @return an order-dependent hash code for the iterable.
   */
  public static <T> int orderDependent(Iterable<T> iterable) {
    int hashCode = 1;
    for (var element : iterable) {
      hashCode = 31 * hashCode + Objects.hashCode(element);
    }
    return hashCode;
  }

  /**
   * Computes an order-independent hash code for an iterable.
   * <p>
   * The hash code is generated by summing the hash codes of all elements. This ensures
   * that the order of elements does not affect the final result. Two iterables with
   * the same elements and frequencies, regardless of their sequence, will produce the
   * same hash code.
   * <p>
   * This method is the correct counterpart for {@code Equals.orderIndependent()}.
   *
   * @param <T>      the type of elements in the iterable.
   * @param iterable the iterable to hash.
   * @return an order-independent hash code for the iterable.
   */
  public static <T> int orderIndependent(Iterable<T> iterable) {
    int hashCode = 0;
    for (var element : iterable) {
      hashCode += Objects.hashCode(element);
    }
    return hashCode;
  }
}